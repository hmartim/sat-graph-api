type: object
description: |
  A unified query structure for hybrid search that combines semantic (vector) and lexical (full-text) search capabilities.

  This schema leverages Oracle 23ai's native hybrid search with Reciprocal Rank Fusion (RRF), allowing the database to optimally merge and rank results from both semantic and lexical searches in a single operation.

  **Search Strategies:**
  - `hybrid`: Combines both semantic and lexical search with database-managed ranking fusion (default)
  - `semantic_only`: Uses only vector similarity search
  - `lexical_only`: Uses only full-text keyword search

  **Basic Usage:**
  For simple queries, only specify the query_text for the desired search type. The system will apply sensible defaults for weights and operators.

  **Advanced Usage:**
  Fine-tune the search with weights, mandatory clauses, boosting terms, and citation-aware scoring to match complex legal domain requirements.

properties:
  strategy:
    type: string
    enum: [hybrid, semantic_only, lexical_only]
    default: hybrid
    description: |
      The search strategy to employ:
      - `hybrid`: Leverage both semantic and lexical search with RRF (recommended for most use cases)
      - `semantic_only`: Only perform vector similarity search
      - `lexical_only`: Only perform keyword/phrase full-text search
    example: "hybrid"

  semantic:
    type: object
    description: "Configuration for semantic (vector embedding) search"
    properties:
      query_text:
        type: string
        description: |
          The natural language query string that will be embedded and used for vector similarity search.
          Use complete sentences or phrases that express the semantic intent.
        example: "políticas de garantia de renda mínima para famílias vulneráveis"

      weight:
        type: number
        format: float
        minimum: 0.0
        maximum: 1.0
        default: 0.5
        description: |
          The relative weight (importance) of the semantic score in hybrid search mode.
          Should sum to 1.0 with lexical.weight for balanced results.
          Higher values prioritize conceptual similarity over exact keyword matches.
        example: 0.7

      top_k:
        type: integer
        format: int32
        minimum: 1
        description: |
          Optional. The number of top candidates to retrieve from semantic search before RRF fusion.
          Useful for tuning performance vs. recall trade-offs in large corpora.
        example: 100
    required:
      - query_text

  lexical:
    type: object
    description: "Configuration for lexical (full-text keyword) search"
    properties:
      query_text:
        type: string
        description: |
          Keywords or phrases for full-text search. Supports exact phrase matching with quotes.
          Examples: "renda básica", "\"artigo 6º\" OR \"artigo 7º\""
        example: "\"artigo 6º\" OR \"renda básica\""

      weight:
        type: number
        format: float
        minimum: 0.0
        maximum: 1.0
        default: 0.5
        description: |
          The relative weight of the lexical score in hybrid search mode.
          Should sum to 1.0 with semantic.weight for balanced results.
          Higher values prioritize exact keyword/phrase matches.
        example: 0.3

      operator:
        type: string
        enum: [AND, OR]
        default: OR
        description: |
          Logical operator for combining multiple keywords in the lexical query.
          - `AND`: All keywords must be present (more restrictive)
          - `OR`: Any keyword can match (more permissive)
        example: "OR"

      top_k:
        type: integer
        format: int32
        minimum: 1
        description: |
          Optional. The number of top candidates to retrieve from lexical search before RRF fusion.
        example: 100
    required:
      - query_text

  clauses:
    type: array
    description: |
      Advanced clauses for mandatory, boosting, or exclusion conditions.
      These map directly to Oracle 23ai's MUST_CONTAIN, SHOULD_CONTAIN, and exclusion operators.
    items:
      type: object
      properties:
        type:
          type: string
          enum: [must_contain, should_contain, must_not_contain]
          description: |
            - `must_contain`: Results MUST include this term/phrase (filters out non-matching documents)
            - `should_contain`: Results containing this term/phrase receive a score boost
            - `must_not_contain`: Results containing this term/phrase are excluded
          example: "must_contain"

        text:
          type: string
          description: "The term or phrase for this clause. Use quotes for exact phrases."
          example: "Constituição Federal"

        boost:
          type: number
          format: float
          minimum: 0.0
          default: 1.5
          description: |
            Score multiplier for `should_contain` clauses. Ignored for other clause types.
            Values > 1.0 increase relevance; values < 1.0 decrease it.
          example: 2.0
      required:
        - type
        - text
    example:
      - type: "must_contain"
        text: "Constituição Federal"
      - type: "should_contain"
        text: "direitos sociais"
        boost: 1.8

  citation_boost:
    type: object
    description: |
      Optional. Boost results containing legal citations (e.g., "artigo 6º", "Lei 8.742/1993").
      Particularly useful in legal/constitutional domains where cited documents carry more authority.
    properties:
      enabled:
        type: boolean
        default: false
        description: "Whether to enable citation-aware scoring"

      multiplier:
        type: number
        format: float
        minimum: 1.0
        default: 1.5
        description: "Score multiplier for documents containing detected legal citations"
        example: 1.8

      patterns:
        type: array
        items:
          type: string
        description: |
          Optional. Custom regex patterns to detect citations beyond the defaults.
          Default patterns include: "artigo \d+", "Lei \d+", "§ \d+", etc.
        example: ["CF/\\d{2}", "Decreto \\d+"]

anyOf:
  - required: [semantic]
  - required: [lexical]

example:
  strategy: "hybrid"
  semantic:
    query_text: "políticas de garantia de renda mínima para famílias vulneráveis"
    weight: 0.7
  lexical:
    query_text: "\"artigo 6º\" OR \"renda básica\""
    weight: 0.3
  clauses:
    - type: "must_contain"
      text: "Constituição Federal"
